import { AppBarProps as AppBarProps_2 } from '@mui/material/AppBar';
import { AuthServerOAuth2ClientConfig } from '@telicent-oss/fe-auth-lib';
import { AutocompleteProps } from '@mui/material';
import { AvatarProps } from '@mui/material/Avatar';
import { AxiosInstance } from 'axios';
import { BaseSelectProps } from '@mui/material';
import { BoxProps } from '@mui/material';
import { BoxTypeMap } from '@mui/system';
import { ButtonBaseProps } from '@mui/material';
import { ButtonProps as ButtonProps_2 } from '@mui/material/Button';
import { ButtonTypeMap } from '@mui/material';
import { CardHeaderProps } from '@mui/material/CardHeader';
import { CardProps as CardProps_2 } from '@mui/material/Card';
import { CheckboxProps } from '@mui/material';
import { ChipProps as ChipProps_2 } from '@mui/material/Chip';
import { ChipProps as ChipProps_3 } from '@mui/material';
import { CircularProgressProps } from '@mui/material/CircularProgress';
import { CircularProgressProps as CircularProgressProps_2 } from '@mui/material';
import { Context } from 'react';
import { Coordinate } from 'ol/coordinate';
import { DatePickerProps as DatePickerProps_2 } from '@mui/x-date-pickers/DatePicker';
import { DateTimePickerProps as DateTimePickerProps_2 } from '@mui/x-date-pickers/DateTimePicker';
import { Dayjs } from 'dayjs';
import { default as default_2 } from 'react';
import { default as default_3 } from 'zod';
import { default as default_4 } from '@telicent-oss/fe-auth-lib';
import { default as default_5 } from 'ol/layer/Base';
import { default as default_6 } from '@mui/material/InputBase';
import { DialogActionsProps } from '@mui/material';
import { DialogContentProps } from '@mui/material';
import { DialogProps } from '@mui/material';
import { DialogTitleProps } from '@mui/material';
import { DividerProps as DividerProps_2 } from '@mui/material/Divider';
import { DrawerProps as DrawerProps_2 } from '@mui/material/Drawer';
import { ExtendButtonBase } from '@mui/material';
import { ExtendedTheme } from '../v1/theme/theme-type';
import { FC } from 'react';
import { FilledSelectProps } from '@mui/material';
import { FilledTextFieldProps } from '@mui/material';
import { FlattenedStyleType } from '@telicent-oss/ontologyservice';
import { FlattenedStyleTypeForFindIcon } from '@telicent-oss/ontologyservice';
import { FontAwesomeIconProps } from '@fortawesome/react-fontawesome';
import { FormHelperTextProps } from '@mui/material';
import { ForwardedRef } from 'react';
import { ForwardRefExoticComponent } from 'react';
import { GridProps } from '@mui/material/Grid';
import { HTMLAttributes } from 'react';
import { IconButtonProps } from '@mui/material/IconButton';
import { IconButtonTypeMap } from '@mui/material';
import { IconProp } from '@fortawesome/fontawesome-svg-core';
import { InputBaseProps } from '@mui/material/InputBase';
import { InputProps } from '@mui/material';
import { JSX as JSX_2 } from '@emotion/react/jsx-runtime';
import { LinearProgressProps } from '@mui/material/LinearProgress';
import { List as ListIcon } from '@telicent-oss/mui-icons-material';
import { ListItemButtonProps } from '@mui/material/ListItemButton';
import { ListItemButtonProps as ListItemButtonProps_2 } from '@mui/material';
import { ListItemIconProps } from '@mui/material/ListItemIcon';
import { ListItemProps } from '@mui/material/ListItem';
import { ListItemProps as ListItemProps_2 } from '@mui/material';
import { ListItemTextProps as ListItemTextProps_2 } from '@mui/material/ListItemText';
import { ListProps } from '@mui/material/List';
import { ListProps as ListProps_2 } from '@mui/material';
import { LocationOn as LocationOnIcon } from '@telicent-oss/mui-icons-material';
import { Map as Map_2 } from 'ol';
import { MapProvider } from 'react-map-gl/maplibre';
import { MapRef } from 'react-map-gl/maplibre';
import { MenuItemProps } from '@mui/material';
import { MenuProps } from '@mui/material';
import { ModalProps as ModalProps_2 } from '@mui/material/Modal';
import { OntologyService } from '@telicent-oss/ontologyservice';
import { OutlinedSelectProps } from '@mui/material';
import { OutlinedTextFieldProps } from '@mui/material';
import { OverridableComponent } from '@mui/types';
import { OverridableComponent as OverridableComponent_2 } from '@mui/material/OverridableComponent';
import { PaperProps } from '@mui/material/Paper';
import { PopoverOrigin } from '@mui/material/Popover';
import { PopoverPosition } from '@mui/material/Popover';
import { PopoverProps } from '@mui/material/Popover';
import { PopoverReference } from '@mui/material/Popover';
import { PopperPlacementType } from '@mui/base';
import { PropsWithChildren } from 'react';
import { QueryClient } from '@tanstack/react-query';
import { QueryKey } from '@tanstack/react-query';
import { ReactNode } from 'react';
import { RefAttributes } from 'react';
import { RefObject } from 'react';
import { SelectChangeEvent } from '@mui/material';
import { SelectProps as SelectProps_2 } from '@mui/material';
import { SizeProp } from '@fortawesome/fontawesome-svg-core';
import { SkeletonTypeMap } from '@mui/material/Skeleton';
import { StackProps } from '@mui/material/Stack';
import { StandardSelectProps } from '@mui/material';
import { StandardTextFieldProps } from '@mui/material';
import { StyleLike } from 'ol/style/Style';
import { SvgIconProps } from '@mui/material/SvgIcon';
import { SvgIconProps as SvgIconProps_2 } from '@mui/material';
import { SxProps } from '@mui/material/styles';
import { SxProps as SxProps_2 } from '@mui/material';
import { TableBodyProps } from '@mui/material';
import { TableCellProps as TableCellProps_2 } from '@mui/material';
import { TableContainerProps as TableContainerProps_2 } from '@mui/material';
import { TableHeadProps } from '@mui/material';
import { TableProps as TableProps_2 } from '@mui/material';
import { TableRowProps as TableRowProps_2 } from '@mui/material';
import { TabProps } from '@mui/material';
import { TabsProps } from '@mui/material';
import { TextFieldProps } from '@mui/material';
import { Theme } from '@mui/material/styles';
import { Theme as Theme_2 } from '@mui/material';
import { ToggleButtonProps } from '@mui/material/ToggleButton';
import { ToolbarProps } from '@mui/material';
import { TreeViewBaseItem } from '@mui/x-tree-view';
import { TypographyProps } from '@mui/material/Typography';
import { URLSearchParamsInit } from 'react-router-dom';
import { UseAutocompleteProps } from '@mui/material/useAutocomplete';
import { useMap } from 'react-map-gl/maplibre';
import { UserInfo } from '@telicent-oss/fe-auth-lib';
import { z } from 'zod';
import { ZodTypeAny } from 'zod';

export declare const anchorMap: Record<MarkerType, MarkerAnchor>;

export declare type AnchorPosition = "center" | "top-left" | "top-middle" | "top-right" | "middle-left" | "middle-right" | "bottom-left" | "bottom-middle" | "bottom-right";

export declare const AppBar: default_2.FC<AppBarProps>;

export declare type AppBarProps = Partial<{
    appName: string;
    beta: boolean;
    startChild: default_2.ReactNode;
    endChild: default_2.ReactNode;
    position: AppBarProps_2["position"];
    version?: string;
    onClick?: (event?: Event | default_2.SyntheticEvent) => void;
    isElevated?: boolean;
    disableBrand?: boolean;
}>;

export declare const AppChrome: default_2.FC<AppChromeProps>;

declare type AppChromeProps = AppBarProps & PropsWithChildren;

export declare const AppSwitch: default_2.FC<{
    apps: AppSwitchLibraryType;
}>;

export declare const AppSwitchLibrarySchema: default_3.ZodObject<{
    id: default_3.ZodString;
    name: default_3.ZodString;
    url: default_3.ZodString;
    icon: default_3.ZodString;
}, "strip", default_3.ZodTypeAny, {
    id: string;
    url: string;
    name: string;
    icon: string;
}, {
    id: string;
    url: string;
    name: string;
    icon: string;
}>;

export declare type AppSwitchLibraryType = default_3.infer<typeof AppSwitchLibrarySchema>[];

declare interface AppSwitchProps extends default_2.HTMLAttributes<HTMLButtonElement> {
    /**
     * The list of applications to include in the app switcher
     * @default []
     */
    apps?: IApps[];
    isLeftAligned?: boolean;
    className?: string;
}

export declare const AuthContext: Context<AuthContextProps | null>;

export declare interface AuthContextProps {
    user: UserInfo | null;
    error: Error | null;
    loading: boolean;
    authClient: default_4;
    api: AxiosInstance;
    login: () => Promise<void>;
    logout: () => Promise<void>;
}

export declare enum AuthEvent {
    AUTHENTICATED = "authenticated",
    REAUTHENTICATED = "reauthenticated",
    USER_CHANGED = "user-changed",
    UNAUTHORIZED = "unauthorized"
}

export declare const AuthModal: React.FC<AuthRedirectModalProps_2>;

export declare namespace authorizeFlowDeprecated {
        {
        AuthModal_2 as AuthModal,
        registerAuthSync,
        useAuthSync,
        onAuthEvent_2 as onAuthEvent,
        broadcastAuthEvent_2 as broadcastAuthEvent,
        AuthEvent_2 as AuthEvent,
        createApi_2 as createApi,
        SessionHandlingConfig,
        AuthConfig,
        ApiFactory
    }
}

export declare const AuthProvider: default_2.FC<AuthProviderProps>;

declare interface AuthProviderProps {
    apiUrl: string;
    config: AuthServerOAuth2ClientConfig;
    queryClient: QueryClient;
    children: default_2.ReactNode;
}

declare interface AuthRedirectModalProps_2 {
    debounceMs?: number;
}

export declare const AuthRedirectUri: FC<AuthRedirectUriProps>;

declare interface AuthRedirectUriProps {
    config: AuthServerOAuth2ClientConfig;
}

export declare const Autocomplete: ForwardRefExoticComponent<AutoCompleteProps & RefAttributes<HTMLDivElement>>;

declare type AutocompleteOption = {
    label: string;
    isRecentSearch: boolean;
};

declare type AutoCompleteProps = {
    label: string;
    value: string | null;
    onChange: (value: string | null) => void;
    options: Option_2[];
    placeholder?: string;
    disabled?: boolean;
    error?: boolean;
    helperText?: string;
    fullWidth?: boolean;
    size?: "small" | "medium";
    required?: boolean;
};

export declare const base64Codec: Codec;

export declare type BaseProps = Omit<TypographyProps, "variant" | "paragraph">;

export declare type BaseRasterLayerConfig = {
    id: string;
    kind: "base-raster";
    provider?: "osm" | "xyz" | "wmts";
    attribution?: string;
    url?: string;
    visible?: boolean;
    previewImage: string;
    label: string;
};

export declare type BaseVectorTileLayerConfig = {
    id: string;
    kind: "base-vector-tiles";
    provider?: "mapbox" | "maptiler" | "arcgis" | "custom";
    url: string;
    styleUrl?: string;
    accessToken?: string;
    visible?: boolean;
    previewImage: string;
    label: string;
};

export declare const BasicMap: default_2.FC<FeatureMapProps>;

export declare interface BasicMapProperties {
    zoom: number;
    center: number[];
    layers?: LayerConfig[];
    controls?: Partial<MapControlsConfig>;
    /**
     * @deprecated Use `layers` instead. This prop will be removed in a future release.
     */
    mapStyleOptions?: LegacyMapConfig;
    markers: MarkerFeature[];
    polygons: PolygonFeature[];
    onFeatureClick?: (ids: string[]) => void;
    onLayersReady?: (isReady: boolean) => void;
}

export declare const BasicMapV2: default_2.ForwardRefExoticComponent<BasicMapProperties & default_2.RefAttributes<BasicMapV2Handle>>;

export declare type BasicMapV2Handle = {
    zoomIn: () => void;
    zoomOut: () => void;
    panToFeature: (id: string) => void;
    panToFeatures: (ids: string[]) => void;
    layersRef: LayersRef;
};

export declare const BinIcon: default_2.FC<SvgIconProps>;

export declare function broadcastAuthEvent(event: AuthEvent): void;

export declare const Button: default_2.ForwardRefExoticComponent<Omit<ButtonProps, "ref"> & default_2.RefAttributes<HTMLButtonElement>>;

export declare type ButtonProps = ButtonProps_2 & {
    style?: "base";
    error?: boolean;
    errorText?: string;
    helperTextProps?: FormHelperTextProps;
};

export declare const ButtonZoomIn: default_2.FC<{
    onClick?: () => void;
}>;

export declare const ButtonZoomOut: default_2.FC<{
    onClick?: () => void;
}>;

export declare const Callback: FC<CallbackProps>;

declare interface CallbackProps {
    clientId: string;
}

export declare const Card: default_2.FC<CardProps>;

export declare const CardActions: default_2.FC<PropsWithChildren>;

export declare const CardContent: default_2.FC<PropsWithChildren>;

export declare const CardHeader: default_2.FC<CardHeaderProps>;

declare type CardProps = Omit<CardProps_2, "classes" | "raised" | "sx"> & Partial<{
    maxWidth: default_2.CSSProperties["maxWidth"];
}>;

export declare const Checkbox: default_2.FC<CustomCheckboxProps>;

export declare const checkOntology: (iconType: string, findIcon: (classUri: string) => FlattenedStyleType) => FlattenedStyleType;

export declare const Chip: default_2.FC<ChipProps>;

export declare type ChipProps = Omit<ChipProps_2, "avatar" | "children" | "classes" | "clickable" | "color" | "component" | "deleteIcon" | "icon" | "skipFocusWhenDisabled" | "sx">;

export declare const ClockIcon: default_2.FC<ClockIconProps>;

declare type ClockIconProps = Omit<FontAwesomeIconProps, "icon"> & {
    color?: "primary" | "inherit";
};

export declare const ClockRotateLeft: default_2.FC<Partial<TeliIconProps>>;

export declare const CloseIcon: default_2.FC<SvgIconProps>;

/**
 * TODO make codec work on URLSearchParams - not just strings
 * WHY
 *  As-is we rely on URLSearchParams constructor to be in
 *  the round-trip of any decoding.
 *  This means the decode fn only partially does the decoding;
 *  it relies on the external use of URLSearchParams.
 *
 * WHEN
 *  A.S.A.P — its a simple refactor - unfortunately I had to
 *  abandon due to ruthless prioritization.
 *
 * HOW
 *  https://telicent.atlassian.net/browse/TELFE-1073
 *
 */
export declare type Codec = {
    param: string;
    encode: (str: string) => string;
    decode: (str: string) => string;
};

export declare const Container: default_2.FC<ContainerProps>;

declare interface ContainerProps extends default_2.HTMLAttributes<HTMLDivElement>, PropsWithChildren {
    /** If true, the left and right padding is removed. */
    disablePadding?: boolean;
    /** Set the maxWidth to match the minWidth of the current breakpoint. Useful
     * when the design is set for fixed sizes instead of trying to accommodate a
     * fluid viewport. It's fluid by default */
    fixed?: boolean;
    /** Sets the maxWidth of the container. The container will grow with the size
     * of the screen. Set to false to disable maxWidth */
    maxWidth?: "xs" | "sm" | "md" | "lg" | "xl" | false;
}

declare interface ControlAreaProps extends Omit<BoxProps, 'position'> {
    position: Position;
}

export declare const CopyToClipboard: default_2.FC<CopyToClipboardProps>;

declare type CopyToClipboardProps = ButtonProps & {
    text: string;
    successMsg?: string;
    ariaLabel?: string;
    testFailure?: boolean;
    style?: String;
};

export declare const createApi: (baseURL?: string, authClient?: default_4) => RequestApi;

export declare const createRequestApi: (baseURL?: string, authClient?: default_4) => RequestApi;

declare interface CustomCheckboxProps extends CheckboxProps {
    label?: string;
    required?: boolean;
}

export declare const DataServiceIcon: default_2.FC<SvgIconProps_2>;

export declare const DataSetIcon: default_2.FC<SvgIconProps_2>;

export declare const DatePicker: default_2.FC<DatePickerProps>;

/**
 * ⚠️ DIVERGENCE:
 * We’re intentionally breaking the “no API changes” guideline here.
 *
 * Background:
 * This control isn’t a native MUI component, even though it comes from the @mui scope.
 * Out of the box, the `x-date-pickers` API requires devs to wire validation through `slotProps.textField`,
 * which is inconsistent with the rest of our MUI-like inputs.
 *
 * What:
 * Exposed `error`, `helperText`, and related props directly on the component.
 *
 * Why:
 * - Aligns this component’s API with other inputs in our DS (TextField, Select, Checkbox, etc.).
 * - Matches MUI’s common pattern of accepting `error` and `helperText` at the top level, making it more intuitive.
 * - Simplifies validation wiring, avoiding the need to engage with `slotProps.textField`.
 * - Reduces cognitive overhead and onboarding time for developers familiar with MUI conventions.
 *
 * Approved by Ash & Vee.
 */
declare type DatePickerProps = DatePickerProps_2 & {
    label?: string;
    value: Dayjs | null;
    error?: boolean;
    helperText?: string;
    textFieldProps?: TextFieldProps;
    minDate?: Dayjs;
    maxDate?: Dayjs;
    errorMsg?: String;
    fullWidth?: boolean;
};

export declare const DateTimePicker: default_2.FC<DateTimePickerProps>;

/**
 * ⚠️ DIVERGENCE:
 * We’re intentionally breaking the “no API changes” guideline here.
 *
 * Background:
 * This control isn’t a native MUI component, even though it comes from the @mui scope.
 * Out of the box, the `x-date-pickers` API requires devs to wire validation through `slotProps.textField`,
 * which is inconsistent with the rest of our MUI-like inputs.
 *
 * What:
 * Exposed `error`, `helperText`, and related props directly on the component.
 *
 * Why:
 * - Aligns this component’s API with other inputs in our DS (TextField, Select, Checkbox, etc.).
 * - Matches MUI’s common pattern of accepting `error` and `helperText` at the top level, making it more intuitive.
 * - Simplifies validation wiring, avoiding the need to engage with `slotProps.textField`.
 * - Reduces cognitive overhead and onboarding time for developers familiar with MUI conventions.
 *
 * Approved by Ash & Vee.
 */
declare type DateTimePickerProps = DateTimePickerProps_2 & {
    textFieldProps?: TextFieldProps;
    helperText?: string;
    fullWidth?: boolean;
    minDateTime?: Dayjs;
    maxDateTime?: Dayjs;
    errorMsg?: string;
    error?: boolean;
};

declare type DefaultOption = {
    label: string;
};

export declare interface DependenciesTable {
    dependencies: {
        [key: string]: string;
    };
    className?: string;
}

export declare const DependenciesTable: default_2.FC<DependenciesTable>;

export declare const Dialog: FC<DialogProps_2>;

declare interface DialogProps_2 extends DialogProps {
    open: boolean;
    onClose: () => void;
    children: ReactNode;
}

export declare const Divider: (props: DividerProps) => JSX_2.Element;

declare interface DividerProps extends DividerProps_2 {
    component?: React.ElementType;
    flexItem?: boolean;
    orientation?: "horizontal" | "vertical";
}

export declare const DownArrowIcon: default_2.FC<DownArrowIconProps>;

declare type DownArrowIconProps = Omit<FontAwesomeIconProps, "icon"> & {
    color?: "primary" | "inherit";
};

export declare const DownloadIcon: FC<DownloadIconProps>;

declare type DownloadIconProps = Omit<FontAwesomeIconProps, "icon"> & {
    color?: "primary" | "inherit";
};

export declare interface DraggableFloatingPanelProps extends HTMLAttributes<HTMLDivElement> {
    /**
     * For linking to associated ToggleButtonState
     */
    targetId: string;
    /**
     * 	Panel title.
     */
    title: string;
    /**
     * Specifies movement boundaries. Accepted values:
     *
     * parent restricts movement
     * within the node's offsetParent (nearest node with position relative or
     * absolute), window, body, Selector like .fooClassName or Element.
     */
    bounds?: "parent" | "window" | "body" | string | Element;
    /**
     * Total number of items
     */
    count?: number;
    /**
     * Component content
     */
    children?: default_2.ReactNode;
    /**
     * Specifies a selector to be used as the handle that initiates drag. Example:
     * drag-handle.
     */
    dragHandleClassName?: string;
    /**
     * The icon to be displayed before the title
     */
    iconBeforeTitle?: default_2.ReactNode;
    /**
     * The x and y property is used to set the default position of the component.
     */
    defaultPosition?: {
        x: number;
        y: number;
    };
}

export declare const DragHandleIcon: default_2.FC<SvgIconProps>;

export declare const Drawer: default_2.ForwardRefExoticComponent<DrawerProps & default_2.RefAttributes<DrawerController>>;

export declare interface DrawerController {
    openDrawer(): void;
    closeDrawer(): void;
    toggleDrawer(): void;
    getContainer(): HTMLDivElement | null;
}

declare interface DrawerPresentationalProps extends Omit<DrawerProps_2, "PaperProps">, default_2.HTMLAttributes<HTMLDivElement> {
    PaperProps?: DrawerProps_2["PaperProps"];
    PaperSx?: SxProps<Theme>;
    drawerWidth?: number;
    children: ReactNode;
    onToggle?: default_2.MouseEventHandler<HTMLButtonElement>;
    id?: string;
}

export declare interface DrawerProps extends Omit<DrawerPresentationalProps, "open" | "onClose" | "ref"> {
    /** (default: true) */
    initialOpen?: boolean;
    onVisibilityChange?: (open: boolean) => void;
    PaperSx?: SxProps_2<Theme_2>;
}

export declare const DropdownButton: default_2.FC<DropdownButtonProps>;

declare interface DropDownButtonMenuItemProps {
    id: string;
    onClick: (val: string) => void;
    faIcon?: IconProp;
    icon?: default_2.ElementType<SvgIconProps>;
    value: string;
    default?: boolean;
    selected: boolean;
}

declare interface DropdownButtonProps {
    ariaLabel: string;
    id: string;
    menuItems: DropDownButtonMenuItemProps[];
}

export declare const DSProviders: React.FC<DSProvidersProps>;

declare type DSProvidersProps = Partial<{
    children: React.ReactNode;
    ontologyService: OntologyService;
}>;

export declare const EditableTextField: default_2.FC<InputText>;

export declare const ENCODE_SEARCH_PARAMS_MODES_Schema: z.ZodUnion<[z.ZodLiteral<"as base64">, z.ZodLiteral<"as uri component">]>;

export declare type ENCODE_SEARCH_PARAMS_MODES_Type = z.infer<typeof ENCODE_SEARCH_PARAMS_MODES_Schema>;

export declare const ErrorFallback: default_2.FC<ErrorFallbackProps>;

export declare type ErrorFallbackProps = Omit<ErrorFallbackWrapperProps, "children"> & ErrorFallbackTextProps;

export declare const ErrorFallbackText: default_2.FC<ErrorFallbackTextProps>;

export declare type ErrorFallbackTextProps = {
    name?: string;
    message?: string;
};

export declare const ErrorFallbackWrapper: default_2.FC<ErrorFallbackWrapperProps>;

export declare type ErrorFallbackWrapperProps = {
    children: default_2.ReactNode;
    height?: number | string;
    sx?: SxProps_2<Theme_2>;
};

export declare const FeatureMap: default_2.FC<FeatureMapProps>;

declare interface FeatureMapProps extends RequiredRest, // everything except initialViewState & geoPolygons
Optionalized {
    theme?: UITheme;
    polygonLayers?: (mapboxgl.FillLayer | mapboxgl.LineLayer | mapboxgl.SymbolLayer)[];
}

export declare const FixedPanel: default_2.FC<PanelProps>;

export declare const FlexBox: default_2.ForwardRefExoticComponent<Omit<StackProps, "ref"> & default_2.RefAttributes<HTMLDivElement>>;

export declare const FlexGrid: default_2.FC<FlexGridProps>;

export declare const FlexGridItem: default_2.FC<FlexGridProps>;

declare type FlexGridProps = Omit<GridProps, "container" | "classes">;

export declare const FloatingPanel: {
    DraggablePanel: FC<DraggableFloatingPanelProps>;
    Provider: FC<FloatingPanelProviderProps>;
    ToggleButton: FC<FloatingPanelToggleButtonProps>;
};

export declare const FloatingPanelContext: default_2.Context<FloatingPanelContextType | undefined>;

export declare interface FloatingPanelContextType {
    toggleVisibility: ToggleFn;
    get: GetFn;
    panels: PanelsType;
}

export declare const FloatingPanelProvider: default_2.FC<FloatingPanelProviderProps>;

export declare interface FloatingPanelProviderProps {
    children: default_2.ReactNode;
}

export declare interface FloatingPanelToggleButtonProps extends Omit<ToggleButtonProps, "sx" | "classes" | "color" | "onClick" | "selected"> {
    /**
     * The unique identifier
     */
    id: string;
    /**
     * Tooltip title
     */
    tooltip?: string;
}

export declare const FloppyDiskIcon: default_2.FC<SvgIconProps>;

export declare const getCodec: (mode?: ENCODE_SEARCH_PARAMS_MODES_Type) => Codec;

declare type GetFn = (id: string, state: "visible" | "minimised") => boolean;

export declare const GRAPH_APP: {
    QUERY_PARAM: {
        NODES: string;
    };
};

export declare const GridIcon: default_2.FC<SvgIconProps>;

export declare const H1: default_2.FC<HeadingProps>;

export declare const H2: default_2.FC<HeadingProps>;

export declare const H3: default_2.FC<HeadingProps>;

export declare const H4: default_2.FC<HeadingProps>;

export declare const H5: default_2.FC<HeadingProps>;

export declare const H6: default_2.FC<HeadingProps>;

export declare type HeadingProps = BaseProps & Partial<{
    /**
     * The type of text style to use.
     */
    variant: "h1" | "h2" | "h3" | "h4" | "h5" | "h6";
}>;

declare interface IApps {
    name: string;
    url: string;
}

export declare const IconButton: default_2.ForwardRefExoticComponent<Omit<IconButtonProps, "ref"> & default_2.RefAttributes<HTMLButtonElement>>;

declare type IconStyle = FlattenedStyleType | FlattenedStyleTypeForFindIcon;

export declare const IESType: default_2.FC<IESTypeProps>;

export declare interface IESTypeProps extends default_2.HTMLAttributes<HTMLElement> {
    backgroundColor: string;
    borderColor: string;
    color: string;
    iconClass: string;
}

declare type InputText = TextFieldProps & {
    value: string;
    onSave: (value: string) => void;
    errorText?: string;
    fullWidth?: boolean;
};

export declare const InsetInMap: default_2.FC<RootPropsType & {
    content: default_2.ReactNode;
    children?: default_2.ReactNode;
    controlArea?: Partial<Record<Position, default_2.ReactNode>>;
}>;

export declare const insetInMap: {
    Background: default_2.FC<BoxProps>;
    Content: default_2.FC<BoxProps>;
    ControlArea: default_2.FC<ControlAreaProps>;
};

export declare const isAuthRedirect: ({ config, url, }: IsAuthRedirectArgs) => boolean;

export declare type IsAuthRedirectArgs = {
    config: AuthServerOAuth2ClientConfig;
    url: string | URL;
};

export declare type LayerConfig = BaseRasterLayerConfig | BaseVectorTileLayerConfig | OverlayVectorLayerConfig;

export declare type LayerMeta = {
    label: string;
    image: string;
    visible: boolean;
};

export declare interface LayerOption {
    uri: string;
    image: string;
    label: string;
}

export declare const LayerSelector: default_2.FC;

export declare const LayerSelectorInsetInMap: default_2.FC<Pick<PresentationalProps_2, "color" | "sx" | "variant">>;

export declare const LayerSelectorPresentationalButton: default_2.FC<PresentationalButtonProps>;

export declare const LayerSelectorPresentationalPopOverV2: default_2.FC<PresentationalProps>;

export declare interface LayerSelectorProps {
    layersRef: LayersRef;
    style?: React.CSSProperties;
}

export declare const LayerSelectorV2: default_2.FC<LayerSelectorProps>;

export declare type LayersRef = React.MutableRefObject<default_5[]>;

export declare type LegacyMapConfig = {
    vectorStyles?: LegacyVectorStyle;
    tileSets?: LegacyTileSet[];
};

export declare type LegacyTileSet = {
    label: string;
    uri: string;
    image: string;
    attribution?: string;
};

export declare type LegacyVectorStyle = {
    label: string;
    uri: string;
    image: string;
};

export declare const License: default_2.FC<LicenseProps>;

declare interface LicenseProps {
    /**
     * Telicent application name
     */
    appName: string;
    /**
     * Telicent application version (should be the same as the one found in package.json)
     */
    appVersion: string;
    /**
     * License expiration date
     */
    expiryDate?: Date | string;
    /**
     * License copyright text
     */
    licenseCopy: ReactNode;
    /**
     * Handler for when acknowledge button is pressed
     */
    onAcknowledge?: () => void;
}

export declare const LinearProgress: default_2.FC<LinearProgressProps>;

export declare const Link: default_2.ForwardRefExoticComponent<Omit<LinkButtonProps, "ref"> & default_2.RefAttributes<HTMLButtonElement>>;

declare type LinkButtonProps = Omit<ButtonProps_2, "variant" | "color">;

export declare const List: default_2.FC<ListProps>;

export { ListIcon }

export declare const ListItem: default_2.FC<ListItemProps>;

export declare const ListItemButton: default_2.FC<ListItemButtonProps>;

export declare const ListItemIcon: default_2.FC<ListItemIconProps>;

export declare const ListItemText: default_2.FC<ListItemTextProps>;

declare interface ListItemTextProps extends Omit<ListItemTextProps_2, "primaryTypographyProps" | "secondaryTypographyProps" | "sx"> {
}

export { LocationOnIcon }

/**
 * BufferedLogger
 *
 * Buffers log calls until a level is set, then flushes buffered messages
 * at or above that level and logs subsequent calls immediately.
 *
 * @example
 * ```ts
 * import { BufferedLogger } from './buffered-logger';
 *
 * const logger = new BufferedLogger();
 *
 * // These calls are buffered
 * logger.debug('debug before init');
 * logger.info('info before init');
 *
 * // Initialize log level and flush buffer
 * logger.setLevel('info');
 *
 * // Only "info" and above were flushed; debug was dropped
 *
 * // Subsequent calls log immediately
 * logger.debug('this won’t show');
 * logger.warn('this will show as warning');
 * ```
 *
 * @method setLevel
 * @param {'debug'|'info'|'warn'|'error'} level — minimum level to log
 *
 * @method debug
 * @param {...any} args — arguments forwarded to console.debug
 *
 * @method info
 * @param {...any} args — arguments forwarded to console.info
 *
 * @method warn
 * @param {...any} args — arguments forwarded to console.warn
 *
 * @method error
 * @param {...any} args — arguments forwarded to console.error
 */
export declare class Logger {
    private buffer;
    private currentLevelNum;
    private ready;
    constructor(level?: LoggerLevel);
    init(level: LoggerLevel): void;
    private shouldLog;
    private flush;
    private record;
    debug: (...args: unknown[]) => void;
    info: (...args: unknown[]) => void;
    warn: (...args: unknown[]) => void;
    error: (...args: unknown[]) => void;
}

export declare type LoggerLevel = LoggerLevelString | number;

export declare const loggerLevelOrder: Record<LoggerLevelString, number>;

export declare type LoggerLevelString = "debug" | "info" | "warn" | "error";

declare type MainProps = JSX.IntrinsicElements["main"];

declare type MapBoxSource = z.infer<typeof MapBoxSourceSchema>;

export declare const MapBoxSourceSchema: z.ZodObject<{
    label: z.ZodString;
    uri: z.ZodString;
    image: z.ZodString;
}, "strip", z.ZodTypeAny, {
    label: string;
    image: string;
    uri: string;
}, {
    label: string;
    image: string;
    uri: string;
}>;

export declare const MapCanvas: default_2.FC<MapCanvasProps>;

declare type MapCanvasConfig = {
    tileSets: StyleOption[];
    vectorStyles?: StyleOption | StyleOption[];
};

export declare interface MapCanvasProps {
    mapRef: default_2.RefObject<MapRef>;
    initialViewState: {
        latitude: number;
        longitude: number;
        zoom: number;
        maxZoom: number;
    };
    cursor?: string;
    onDragStart: () => void;
    onDragEnd: () => void;
    onMouseEnter: () => void;
    onMouseLeave: () => void;
    onLoad: () => void;
    defaultStyle?: string;
    attributionControl: boolean;
    markers: ResultMarker[];
    geoPolygons: GeoJSON.FeatureCollection;
    selected: string[];
    onClickMarker?: (m: ResultMarker) => void;
    findByClassUri: (u: string) => any;
    polygonLayers?: (mapboxgl.FillLayer | mapboxgl.LineLayer | mapboxgl.SymbolLayer)[];
}

/**
 * For state that is shared throughout the app
 */
export declare const MapCanvasProvider: default_2.FC<{
    initialMapStyleConfig: MapStyleConfig;
    children: ReactNode;
}>;

export declare interface MapCanvasState {
    styleSelector: StyleSelectorState;
}

export declare const MapCanvasV2: default_2.FC<MapCanvasV2Props>;

export declare type MapCanvasV2Props = {
    layersRef: LayersRef;
    mapInstanceRef: MapInstanceRef;
    onFeatureClick?: (ids: string[]) => void;
    zoom: number;
    center: Coordinate;
    controls?: Partial<MapControlsConfig>;
};

export declare interface MapControlsConfig {
    showZoom: boolean;
    showRotate: boolean;
    showFullScreen: boolean;
    showLayerSelector: boolean;
}

export declare const MapIcon: default_2.FC<SvgIconProps>;

export declare type MapInstanceRef = React.MutableRefObject<Map_2 | null>;

export { MapProvider }

declare interface MapStyleConfig {
    vectorStyles?: StyleOption | StyleOption[];
    tileSets?: StyleOption[];
}

export declare const MapToggleButtonPresentational: default_2.FC<SecondaryButtonProps>;

export declare enum MarkerAnchor {
    CENTER = "center",
    BOTTOM_MIDDLE = "bottom-middle",
    TOP_MIDDLE = "top-middle"
}

export declare interface MarkerFeature {
    id: string;
    geohash: string;
    type?: string;
    name?: string;
    uri?: string;
    meta?: Record<string, any>;
    style?: MarkerStyle;
}

export declare interface MarkerStyle {
    fallbackText?: string;
    markerType?: MarkerType;
    color?: string;
    strokeWidth?: number;
    backgroundColor?: string;
    innerSvg?: string;
    borderColor?: string;
    size?: number;
    zIndex?: number;
}

export declare type MarkerType = "pin" | "circle" | "icon" | string;

declare interface MenuItem {
    id: string;
    onClick?: (event?: Event | default_2.SyntheticEvent) => void;
    label?: string | default_2.ReactNode;
    startIcon?: default_2.ReactNode;
    endIcon?: default_2.ReactNode;
}

export declare const MiniSearchAutocomplete: <Value extends AutocompleteOption = AutocompleteOption, Multiple extends boolean = false, DisableClearable extends boolean = false, FreeSolo extends boolean = false>(props: MiniSearchAutocompleteProps<Value, Multiple, DisableClearable, FreeSolo> & {
    ref?: default_2.Ref<HTMLDivElement>;
}) => default_2.ReactElement | null;

export declare interface MiniSearchAutocompleteProps<Value extends AutocompleteOption = AutocompleteOption, Multiple extends boolean = false, DisableClearable extends boolean = false, FreeSolo extends boolean = false> extends UseAutocompleteProps<Value, Multiple, DisableClearable, FreeSolo> {
    /**
     * Element placed after the search icon
     */
    endIcon?: default_2.ReactNode;
    /**
     * If `true`, the `input` will indicate an error.
     */
    error?: boolean;
    /**
     * The id of the `input` element.
     */
    id?: string;
    /**
     * If true, a loading indicator will be visible.
     */
    loading?: boolean;
    /**
     * If `true`, disables the entire control (input, popper trigger, and action).
     */
    disabled?: boolean;
    /**
     * Name attribute of the input element.
     */
    name?: string;
    /**
     * 	The short hint displayed in the input before the user enters a value.
     */
    placeholder?: string;
    /**
     * Props which will be applied to the circular progress indicator when loading
     * is set to true
     */
    progressProps?: ProgressProps;
    /**
     * Render the option
     * @param props The props to apply on the li element.
     * @param option The option to render.
     * @returns
     */
    renderOption?: (props: default_2.HTMLAttributes<HTMLLIElement> & {
        key: any;
    }, option: Value) => default_2.ReactNode;
    /**
     * Callback fired when the search button is clicked
     *
     * `(event: React.MouseEvent<HTMLButtonElement>) => void;`
     */
    onSearch?: default_2.MouseEventHandler<HTMLElement>;
    /**
     * Callback fired when the a key is pressed
     *
     * `(event: React.KeyboardEvent<HTMLButtonElement>) => void;`
     */
    onKeyDown?: default_2.KeyboardEventHandler<HTMLInputElement>;
}

export declare const MiniSearchBox: (props: MiniSearchBoxProps) => JSX_2.Element;

export declare interface MiniSearchBoxProps extends SearchInputBaseProps {
    /**
     * If true, a loading indicator will be visible
     */
    loading?: boolean;
    /**
     * Element placed after the search icon
     */
    endIcon?: default_2.ReactNode;
    /**
     * Callback fired when the search button is clicked
     *
     * `(event: React.MouseEvent<HTMLButtonElement>) => void;`
     */
    onSearch?: default_2.MouseEventHandler<HTMLButtonElement>;
    /**
     * Callback fired when the down arrow button is clicked
     *
     * `(event: React.MouseEvent<HTMLButtonElement>) => void;`
     */
    onTogglePopOver?: default_2.MouseEventHandler<HTMLButtonElement>;
}

export declare const MinusCircleIcon: default_2.FC<SvgIconProps>;

export declare const Modal: default_2.FC<ModalProps>;

export declare type ModalProps = Omit<ModalProps_2, "slots" | "slotProps" | "BackdropComponent" | "BackdropProps" | "closeAfterTransition" | "components" | "componentsProps" | "container" | "disableAutoFocus" | "disableEnforceFocus" | "disableEscapeKeyDown" | "disableRestoreFocus" | "hideBackdrop" | "keepMounted" | "onBackdropClick" | "onTransitionEnter" | "onTransitionExit"> & {
    onClose: ((event: {}, reason: "backdropClick" | "escapeKeyDown" | "closeButtonClick") => void) | undefined;
    hideCloseButton?: boolean;
};

export declare const mui: {
    IconButton: ExtendButtonBase<IconButtonTypeMap<    {}, "button">>;
    Button: ExtendButtonBase<ButtonTypeMap<    {}, "button">>;
    Box: OverridableComponent<BoxTypeMap<    {}, "div", Theme_2>>;
};

declare type MUIAutocompleteProps<Option> = AutocompleteProps<Option, false, false, true>;

declare type MUIButtonBaseProps = Omit<ButtonBaseProps, "centerRipple" | "classes" | "action" | "disableRipple" | "disableTouchRipple" | "focusRipple" | "focusVisibleClassName" | "onFocusVisible" | "TouchRippleProps" | "touchRippleRef" | "sx">;

declare type MUIChipProps = Omit<ChipProps_3, "variant" | "color" | "avatar" | "classes">;

declare type NavProps = JSX.IntrinsicElements["nav"];

export declare function onAuthEvent(callback: (event: AuthEvent) => void): () => void;

export declare const OntologyHierarchy: default_2.FC<OntologyHierarchyProps>;

declare interface OntologyHierarchyProps {
    instanceId: string;
    data: OntologyInputHierarchy;
    descendantCount?: boolean;
    isDraggable?: boolean;
    dragEvent?: (event: default_2.DragEvent<HTMLElement>, nodeType: string) => void;
    isClickable?: boolean;
    clickEvent?: (nodeId: string) => void;
    baseKey?: string;
    filterIds?: string[];
    expandAll?: boolean;
    expandElement?: boolean;
}

export declare interface OntologyInputHierarchy {
    name: string;
    id: string;
    ontology: IconStyle;
    children?: OntologyInputHierarchy[];
}

declare type Option_2 = {
    label: string;
    value: string;
};

declare type Optional = Pick<Picked, "initialViewState" | "geoPolygons" | "attributionControl">;

declare type Optionalized = Partial<Optional>;

export declare interface Options {
    value: string;
    label: string;
}

export declare interface OverlayConfig {
    id: string;
    type: OverlayType;
    source: string | GeoJSON.FeatureCollection;
    visible?: boolean;
    zIndex?: number;
    opacity?: number;
    style?: Record<string, any>;
    data?: OverlayFeatureConfig[];
}

export declare type OverlayFeatureConfig = {
    type: "Point" | "Polygon" | "MultiPolygon";
    coordinates: number[] | number[][] | number[][][];
    label?: string;
    id?: string;
    marker?: string | MarkerStyle;
    meta?: Record<string, any>;
};

export declare type OverlayType = "tile" | "geojson" | "vector";

export declare type OverlayVectorLayerConfig = {
    id: string;
    kind: "overlay-vector";
    data: OverlayFeatureConfig[];
    style?: StyleLike;
    visible?: boolean;
    zIndex?: number;
    projection?: string;
};

declare interface PanelProps extends HTMLAttributes<HTMLDivElement> {
    /**
     * For linking to associated ToggleButtonState
     */
    targetId: string;
    /**
     * 	Panel title.
     */
    title: string;
    /**
     * Total number of items
     */
    count?: number;
    /**
     * Component content
     */
    children?: default_2.ReactNode;
    /**
     *
     */
    dragHandle?: default_2.ReactNode;
    /**
     * Specifies a selector to be used as the handle that initiates drag. Example:
     * drag-handle.
     */
    dragHandleClassName?: string;
    /**
     * The icon to be displayed before the title
     */
    iconBeforeTitle?: default_2.ReactNode;
    /**
     * The x and y property is used to set the default position of the component.
     */
    defaultPosition?: {
        x: number;
        y: number;
    };
}

export declare interface PanelState {
    visible: boolean;
    minimised: boolean;
}

export declare interface PanelsType extends Record<string, PanelState> {
}

export declare const Paper: default_2.ForwardRefExoticComponent<Omit<PaperProps, "ref"> & default_2.RefAttributes<HTMLDivElement>>;

export declare function parseOrThrowWithInput<TSchema extends ZodTypeAny>(schema: TSchema, data: unknown): z.output<TSchema>;

declare type Picked = Pick<MapCanvasProps, "initialViewState" | "defaultStyle" | "attributionControl" | "markers" | "geoPolygons" | "selected" | "onClickMarker" | "findByClassUri">;

export declare const PlayIcon: default_2.FC<SvgIconProps>;

export declare const PlusCircleIcon: default_2.FC<SvgIconProps>;

export declare interface PolygonFeature {
    id: string;
    type: PolygonType;
    coordinates: Coordinate;
    name: string;
    meta?: Record<string, any>;
    style?: PolygonStyle;
}

export declare interface PolygonStyle {
    color: string;
    backgroundColor: string;
}

export declare type PolygonType = "Polygon" | "MultiPolygon";

/**
 * A PopOver can be used to display some content on top of another.
 *
 * Things to know when using the PopOver component:
 * - The component is built on top of the Modal component.
 */
export declare const PopOver: (props: PopOverProps) => JSX_2.Element;

declare interface PopOverProps extends Omit<ModalProps, "children"> {
    /**
     * Used to set the position of the pop over
     */
    anchorEl?: PopoverProps["anchorEl"];
    /**
     * Anchor element anchor. This is the point on the anchor where the pop over's
     * `anchorEl` will attach to. Should not e used when anchorReference is
     * 'anchorPosition'.
     *
     * Options:
     * vertical: [top, center, bottom];
     * horizontal: [left, center, right].
     * @default {
     *   vertical: 'top',
     *   horizontal: 'left',
     * }
     */
    anchorOrigin?: PopoverOrigin;
    /**
     * This is the position that may be used to set the position of the pop over.
     * The coordinates are relative to the application's client area.
     */
    anchorPosition?: PopoverPosition;
    /**
     * This determines which anchor prop to refer to when setting
     * the position of the pop over.
     * @default 'anchorEl'
     */
    anchorReference?: PopoverReference;
    /**
     * The content of the component.
     */
    children?: default_2.ReactNode;
    /**
     * If `true`, the component is shown.
     */
    open: boolean;
    /**
     * This is the point on the pop over which
     * will attach to the anchor's origin.
     *
     * Options:
     * vertical: [top, center, bottom, x(px)];
     * horizontal: [left, center, right, x(px)].
     * @default {
     *   vertical: 'top',
     *   horizontal: 'left',
     * }
     */
    transformOrigin?: PopoverOrigin;
    width?: number;
}

export declare type Position = "topLeft" | "top" | "topRight" | "right" | "bottomRight" | "bottom" | "bottomLeft" | "left" | "center";

export declare const PreferredLabelCache: {
    init: (ontologyService: OntologyService) => Promise<void>;
    get: (val: string) => string;
};

export declare interface PresentationalButtonProps extends Pick<ButtonProps, "sx" | "variant" | "color" | "size"> {
    data?: default_5[];
    anchorEl: HTMLButtonElement | null;
    onClickDropdown: ButtonProps["onClick"];
    selectedIndex: number;
}

export declare interface PresentationalProps extends Pick<ButtonProps, "sx" | "variant" | "color" | "size"> {
    data: default_5[];
    anchorEl: HTMLButtonElement | null;
    onCloseDropdown: PopOverProps["onClose"];
    onListItemClick: (label: string) => void;
    selectedIndex: number;
}

declare interface PresentationalProps_2 extends Pick<ButtonProps, "sx" | "variant" | "color" | "size"> {
    selectedIndex: number;
    data: LayerOption[];
    anchorEl: HTMLButtonElement | null;
    onCloseDropdown: PopOverProps["onClose"];
    onClickDropdown: ButtonProps["onClick"];
    onListItemClick: (index: number) => void;
}

declare interface ProgressProps extends Omit<CircularProgressProps, "classes" | "color" | "size" | "sx" | "thickness"> {
}

export declare const RecentSearches: default_2.FC<RecentSearchProps>;

declare type RecentSearchProps = Partial<{
    nothingFoundText: string;
    children: default_2.ReactNode;
}>;

export declare const renderErrorToHtml: (error: unknown, context?: string) => void;

declare interface RequestApi {
    instance: AxiosInstance;
    withSessionHandling: (config: SessionHandlingConfig_2) => RequestApi;
    build: () => {
        instance: AxiosInstance;
    };
}

declare type RequiredRest = Omit<Picked, keyof Optional>;

declare type ResultMarker = {
    geohash: string;
    type: string;
    uri: string;
    name: string;
};

declare type RootPropsType = Omit<BoxProps, 'children' | 'content'>;

export declare type Scrollable = HTMLDivElement | (Window & typeof globalThis);

export declare const SearchAutocomplete: <Option>({ autoFocus, autoHighlight, error, fullWidth, getOptionKey, getOptionLabel, helperText, id, inputValue, isOptionEqualToValue, label, listboxMaxHeight, loading, loadingText, name, onChange, onInputChange, openOnFocus, options, placeholder, width, }: SearchAutocompleteProps<Option>) => JSX_2.Element;

export declare const SearchAutocompleteDialog: default_2.FC<SearchAutocompleteDialogProps>;

declare type SearchAutocompleteDialogProps<SearchOption = {
    label: string;
}> = Omit<SearchAutocompleteProps<SearchOption>, "listboxMaxHeight" | "fullWidth"> & {
    open: DialogProps["open"];
    children: default_2.ReactNode;
} & Partial<{
    onClose: DialogProps["onClose"];
}>;

declare type SearchAutocompleteProps<Option = DefaultOption> = {
    /**
     * Array of options.
     */
    options: MUIAutocompleteProps<Option>["options"];
} & Partial<{
    autoHighlight: MUIAutocompleteProps<Option>["autoHighlight"];
    /**
     * If true, the input element is focused during the first mount.
     */
    autoFocus: boolean;
    /**
     * 	If true, the component will indicate an error.
     */
    error: boolean;
    /**
     * If true, the component will take up the full width of its container.
     */
    fullWidth: boolean;
    /**
     * Can be used to give context. If ' ' is provided, the component reserves one
     * line height for displaying a future message.
     */
    helperText: string;
    id: MUIAutocompleteProps<Option>["id"];
    inputValue: MUIAutocompleteProps<Option>["inputValue"];
    /**
     * The label content
     */
    label: string;
    /**
     * The maximum height of the autocomplete list box
     */
    listboxMaxHeight: number;
    loading: MUIAutocompleteProps<Option>["loading"];
    loadingText: MUIAutocompleteProps<Option>["loadingText"];
    openOnFocus: MUIAutocompleteProps<Option>["openOnFocus"];
    name: string;
    /**
     * 	The short hint displayed in the input before the user enters a value.
     */
    placeholder: string;
    /**
     * The width of the component
     */
    width: number;
    getOptionLabel: MUIAutocompleteProps<Option>["getOptionLabel"];
    getOptionKey: MUIAutocompleteProps<Option>["getOptionKey"];
    isOptionEqualToValue: MUIAutocompleteProps<Option>["isOptionEqualToValue"];
    onChange: MUIAutocompleteProps<Option>["onChange"];
    onInputChange: MUIAutocompleteProps<Option>["onInputChange"];
}>;

export declare const SearchBox: default_2.FC<SearchBoxProps>;

export declare interface SearchBoxProps<Value = string> extends default_2.ComponentProps<typeof default_6> {
    /**
     * If true, the input element is focused during the first mount.
     */
    autoFocus?: boolean;
    /**
     * 	Pass a ref to the input element.
     */
    inputRef?: default_2.ForwardedRef<HTMLInputElement> | default_2.RefObject<HTMLInputElement>;
    /**
     * Callback fired when the input looses focus (i.e. blurred).
     * Notice that the first argument (event) might be undefined.
     * @param event
     * @returns void
     */
    onBlur?: (event: default_2.FocusEvent<HTMLInputElement>) => void;
    /**
     * Callback fired when the value is changed.
     * @param event The event source of the callback. You can pull out the new value by accessing event.target.value (string).
     * @returns void
     */
    onChange?: (event: default_2.ChangeEvent<HTMLInputElement>) => void;
    /**
     * Callback fired when the search button is clicked.
     * @param event
     * @returns
     */
    onSearch?: (event: default_2.MouseEvent<HTMLFormElement>) => void;
    /**
     * Name attribute of the input element.
     */
    name?: InputBaseProps["name"];
    /**
     * The short hint displayed in the input before the user enters a value.
     */
    placeholder?: InputBaseProps["placeholder"];
    /**
     * The value of the input element, required for a controlled component.
     */
    value?: Value;
    width?: number;
}

export declare const SearchIcon: default_2.FC<SearchIconProps>;

declare type SearchIconProps = Omit<FontAwesomeIconProps, "icon"> & {
    color?: "primary" | "inherit";
};

declare interface SearchInputBaseProps extends Omit<default_2.HTMLAttributes<HTMLDivElement>, "children" | "color" | "defaultValue" | "onBlur" | "onChange" | "onFocus" | "onInvalid" | "onKeyDown" | "onKeyUp"> {
    /**
     * If `true`, the `input` element is focused during the first mount.
     */
    autoFocus?: boolean;
    /**
     * If `true`, the `input` will indicate an error.
     */
    error?: boolean;
    /**
     * If `true`, the `input` will take up the full width of its container.
     * @default false
     */
    fullWidth?: boolean;
    /**
     * Can be used to give context. If ' ' is provided, the component reserves one
     * line height for displaying a future message.
     */
    helperText?: string;
    /**
     * The id of the `input` element.
     */
    id?: string;
    /**
     * Pass a ref to the `input` element.
     */
    inputRef?: default_2.Ref<any>;
    /**
     * Maximum number of rows to display when multiline option is set to true.
     */
    maxRows?: string | number;
    /**
     * Minimum number of rows to display when multiline option is set to true.
     */
    minRows?: string | number;
    /**
     * If true, a text area auto size element will be rendered
     * @default false;
     */
    multiline?: boolean;
    /**
     * Name attribute of the `input` element.
     */
    name?: string;
    /**
     * Callback fired when the `input` is blurred.
     *
     * `(event: React.FocusEvent<HTMLTextAreaElement | HTMLInputElement>) => void;`
     * Note: The first argument (event) might be undefined.
     */
    onBlur?: default_2.FocusEventHandler<HTMLInputElement | HTMLTextAreaElement>;
    /**
     * Callback fired when the value is changed
     *
     * `(event: React.ChangeEvent) => void`
     * @param {React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement>} event The event source of the callback.
     * You can pull out the new value by accessing `event.target.value` (string).
     */
    onChange?: default_2.ChangeEventHandler<HTMLTextAreaElement | HTMLInputElement>;
    /**
     * `(event: React.FocusEvent<HTMLTextAreaElement | HTMLInputElement>) => void;`
     */
    onFocus?: default_2.FocusEventHandler<HTMLInputElement | HTMLTextAreaElement>;
    /**
     * `(event: React.KeyboardEvent<HTMLTextAreaElement | HTMLInputElement>) => void;`
     */
    onKeyDown?: default_2.KeyboardEventHandler<HTMLTextAreaElement | HTMLInputElement>;
    /**
     * `(event: React.KeyboardEvent<HTMLTextAreaElement | HTMLInputElement>) => void;`
     */
    onKeyUp?: default_2.KeyboardEventHandler<HTMLTextAreaElement | HTMLInputElement>;
    /**
     * Callback fired when the `input` doesn't satisfy its constraints.
     *
     * `(event: React.FormEvent<HTMLTextAreaElement | HTMLInputElement>) => void;`
     */
    onInvalid?: default_2.FormEventHandler<HTMLInputElement | HTMLTextAreaElement>;
    /**
     * The short hint displayed in the input before the user enters a value.
     */
    placeholder?: string;
    /**
     * Props which will be applied to the circular progress indicator when loading
     * is set to true
     */
    progressProps?: ProgressProps;
    /**
     * Number of rows to display when multiline option is set to true.
     */
    rows?: string | number;
    /**
     * The value of the `input` element, required for a controlled component.
     */
    value?: unknown;
    /**
     * If `true`, disables the entire control (input and action button).
     */
    disabled?: boolean;
}

export declare const SearchResults: default_2.FC<SearchResultsProps>;

declare type SearchResultsProps = Partial<{
    totalResults: number;
    nothingFoundText: string;
    children: default_2.ReactNode;
}>;

declare type SecondaryButtonProps = Omit<ButtonProps_2, "variant" | "color">;

export declare const Select: default_2.ForwardRefExoticComponent<(Omit<FilledSelectProps & BaseSelectProps<unknown> & {
    options: Options[];
    width?: number | string;
    helperText?: default_2.ReactNode;
}, "ref"> | Omit<StandardSelectProps & BaseSelectProps<unknown> & {
    options: Options[];
    width?: number | string;
    helperText?: default_2.ReactNode;
}, "ref"> | Omit<OutlinedSelectProps & BaseSelectProps<unknown> & {
    options: Options[];
    width?: number | string;
    helperText?: default_2.ReactNode;
}, "ref">) & default_2.RefAttributes<HTMLInputElement>>;

export { SelectChangeEvent }

export declare type SelectProps = SelectProps_2 & {
    options: Options[];
    width?: number | string;
    helperText?: default_2.ReactNode;
};

declare interface SessionHandlingConfig_2 {
    queryClient?: QueryClient;
    keysToInvalidate?: QueryKey[];
}

export declare const setupOAuthEventListeners: (OAuth2Client: default_4, onAuthSuccess?: (redirect?: URL) => void, onAuthError?: (error?: Error) => void) => (() => void);

export declare const Skeleton: OverridableComponent_2<SkeletonTypeMap<    {}, "span">>;

declare interface StandardLayoutProps {
    /**
     * The telicent application name
     */
    appName: string;
    /**
     * Has the application moved into its second phase of testing and is ready for external use by customers or clients?
     * @default false
     */
    beta?: boolean;
}

export declare type StyleConfig = Partial<{
    fillColor: string;
    strokeColor: string;
    strokeWidth: number;
    radius: number;
    text?: string;
}> | ((feature: unknown) => StyleConfig);

declare type StyleOption = {
    label: string;
    uri: string;
    image: string;
};

declare interface StyleSelectorState {
    selected: MapBoxSource | null;
    mapConfig: MapCanvasConfig;
    props: {
        onChange: (v: LayerOption) => void;
        data: StyleOption[];
    };
}

declare type TableCellProps = Omit<TableCellProps_2, "sx" | "classes">;

declare type TableContainerProps = Omit<TableContainerProps_2, "sx" | "classes">;

declare type TableProps = Omit<TableProps_2, "sx" | "classes" | "size">;

declare type TableRowProps = Omit<TableRowProps_2, "sx" | "classes">;

export declare const TeliAddIcon: default_2.FC<Partial<TeliIconProps>>;

export declare const TeliAppSwitch: FC<AppSwitchProps>;

export declare function TeliAutocomplete<Value, Multiple extends boolean = false, DisableClearable extends boolean = false, FreeSolo extends boolean = false>({ error, fullWidth, helperText, label, loading, maxHeight, mode, placeholder, startAdornment, width, getChipIcon, getOptionLabel, ...other }: TeliAutocompleteProps<Value, Multiple, DisableClearable, FreeSolo>): JSX_2.Element;

declare interface TeliAutocompleteProps<Value, Multiple extends boolean = false, DisableClearable extends boolean = false, FreeSolo extends boolean = false> extends Omit<AutocompleteProps<Value, Multiple, DisableClearable, FreeSolo>, "renderInput" | "ChipProps" | "clearIcon" | "classes" | "clearText" | "closeText" | "componentsProps" | "ListboxProps" | "ListboxComponent" | "openText" | "PaperComponent" | "PopperComponent" | "popupIcon" | "size" | "slotProps" | "sx"> {
    /** If true, the component will be rendered in an error state */
    error?: boolean;
    /** Used to determine the icon elment of a given option */
    getChipIcon?: (option: Value) => any;
    /** The label content. */
    helperText?: string;
    /** The label content. */
    label?: string | default_2.ReactNode;
    /** Maximum height of the menu component */
    maxHeight?: number;
    /** The autocomplete mode with predefined defaults */
    mode?: "search";
    placeholder?: string;
    /** Element placed before the input element */
    startAdornment?: default_2.ReactNode;
    /** Width of the component. */
    width?: number;
}

export declare const TeliBasicLayout: default_2.FC<TeliBasicLayoutProps>;

declare type TeliBasicLayoutProps = Partial<{
    children: ReactNode;
}>;

export declare const TeliBasicMenu: default_2.FC<TeliBasicMenuProps>;

declare interface TeliBasicMenuProps {
    /**
     * The id of the Button element.
     */
    buttonId?: string;
    /**
     * The menu contents.
     */
    children?: default_2.ReactNode;
    /**
     * If true, the component is initially open. Use when the component open state
     * is not controlled (i.e. the open prop is not defined).
     */
    defaultOpen?: boolean;
    /** If true, the component will be displayed in a disabled state */
    disabled?: boolean;
    /**
     * The message to be displayed when menu items are empty.
     */
    emptyMessage?: string;
    /**
     * Element placed after the children.
     */
    endIcon?: default_2.ReactNode;
    /**
     * The id of the MenuList component.
     */
    listId?: string;
    /**
     * The content of the Button component.
     */
    label: string | default_2.ReactNode;
    /**
     * Menu content items.
     */
    menuItems?: MenuItem[];
    /**
     * If true, the menu component will be shown.
     */
    open?: boolean;
    /**
     * Callback fired when the component requests to be opened. Use it for
     * controlled mode.
     */
    onOpen?: default_2.MouseEventHandler<HTMLButtonElement>;
    /**
     * Callback fired when the component requests to be closed. Use it for
     * controlled mode.
     */
    onClose?: (event: MouseEvent | TouchEvent) => void;
    /**
     * Element placed before the children.
     */
    startIcon?: default_2.ReactNode;
    /**
     * Tooltip contents refer to [Button component](/?path=/docs/components-telibutton--docs).
     */
    tooltip?: string;
    /**
     * The variant to use.
     */
    variant?: "tertiary" | "basic";
    /**
     * Width of the menu component.
     */
    width?: number;
    /**
     * Vertical menu placement.
     */
    xPlacement?: PopperPlacementType;
    /**
     * Horizontal menu placement.
     */
    yPlacement?: PopperPlacementType;
}

export declare const TeliBasicTable: default_2.FC<TeliBasicTableProps>;

declare interface TeliBasicTableProps {
    /**
     * Table column headers
     */
    columns?: Array<string | Record<string, string>>;
    /**
     * Table body rows
     */
    rows?: Array<Array<string>>;
    name?: TeliTableProps["name"];
    addBorderToLastRow?: TeliTableRowProps["addBorderToLastRow"];
    align?: TeliTableCellProps["align"];
    bordered?: TeliTableContainerProps["bordered"];
    /**
     * A short heading for the table content
     */
    caption?: string;
    compact?: TeliTableProps["compact"];
    maxHeight?: TeliTableContainerProps["maxHeight"];
    minWidth?: TeliTableProps["minWidth"];
    /**
     * If true, a column of numbered rows will be added at the start of table
     */
    numberRows?: boolean;
    /**
     * The heading for the numbered rows column
     */
    numberColumnHeading?: string;
    /**
     * Render column cell
     * @param column Column data
     * @param index
     * @returns JSX.Element
     */
    renderColumnCell?: (column: any, index?: number) => JSX.Element;
    stickyHeader?: TeliTableProps["stickyHeader"];
    /**
     * If true, the first column will be rendered as a table header
     */
    verticalHeader?: boolean;
}

/**
 * Note: The application color is taken from index.css
 */
export declare const TeliBrand: default_2.FC<TeliBrandProps>;

declare interface TeliBrandProps extends StandardLayoutProps, default_2.HTMLAttributes<HTMLAnchorElement> {
    /**
     * How big should the brand component be?
     * @default base
     */
    size?: "base" | "jumbo";
    /**
     * URL
     */
    href?: string;
    /**
     * Where to display the linked URL, as the name for a browsing context (a tab, window, or <iframe>).
     */
    target?: string;
    /**
     * The relationship of the linked URL as space-separated link types
     */
    rel?: string;
}

export declare const TeliButton: default_2.ForwardRefExoticComponent<Omit<TeliButtonProps, "ref"> & default_2.RefAttributes<HTMLButtonElement>>;

declare interface TeliButtonBaseProps extends MUIButtonBaseProps {
    /**
     * The variant to use.**Note**: Use primary instead of contained, secondary
     * instead of outline and tertiary instead of text. These variants will be
     * removed in the next version
     * @default primary
     */
    variant?: "primary" | "secondary" | "tertiary" | "link" | "basic";
    linePosition?: "left" | "right" | "center";
    /**
     * The color of the component.
     */
    color?: "danger";
    /**
     * The URL to link to when the button is clicked. If defined, an a element
     * will be used as the root node.
     */
    href?: string;
    /**
     * Element placed before the children.
     */
    startIcon?: default_2.ReactNode;
    /**
     * Element placed after the children.
     */
    endIcon?: default_2.ReactNode;
    /**
     * The size of the component.
     */
    size?: "small" | "medium" | "large";
}

declare interface TeliButtonProps extends TeliButtonBaseProps {
    /**
     * Tooltip contents
     */
    tooltip?: string;
    /**
     * Tooltip placement.
     * @default bottom
     */
    tooltipPlacement?: "bottom-end" | "bottom-start" | "bottom" | "left-end" | "left-start" | "left" | "right-end" | "right-start" | "right" | "top-end" | "top-start" | "top";
}

export declare const TelicentHorizontalSVG: default_2.FC<SvgIconProps>;

export declare const TelicentMark: default_2.FC<TelicentMarkProps>;

declare interface TelicentMarkProps extends SvgIconProps {
    transparentBg?: boolean;
}

/**
 * Checkboxes can be used to turn one or more options on or off.
 * If you have multiple options appearing in a list, you can preserve space by using checkboxes instead of on/off switches.
 * If you have a single option, avoid using a checkbox and use an on/off switch instead.
 * More information about this component can be found [here](https://mui.com/material-ui/react-checkbox/)
 */
export declare const TeliCheckbox: FC<TeliCheckboxProps>;

declare interface TeliCheckboxProps extends CheckboxProps {
    label?: string;
}

export declare const TeliChip: default_2.FC<TeliChipProps>;

declare interface TeliChipProps extends MUIChipProps {
    href?: string;
    variant?: "primary" | "secondary" | "tertiary" | "basic";
}

export declare const TeliCloseIcon: default_2.FC<Partial<TeliIconProps>>;

export declare const TeliDeleteIcon: default_2.FC<Partial<TeliIconProps>>;

/**
 * A Dialog is a type of modal window that appears in front of app content to provide critical information or ask for a decision.
 * They can also be used to inform users about a task and can contain critical information, require decisions, or involve multiple tasks.
 * Dialogs disable all app functionality when they appear, and remain on screen until confirmed, dismissed, or a required action has been taken.
 * Dialogs are purposefully interruptive, so they should be used sparingly.
 * More information about how this component can be used can be found [here](https://mui.com/material-ui/react-dialog/#scrolling-long-content)
 */
export declare const TeliDialog: FC<DialogProps>;

export declare const TeliDialogActions: FC<DialogActionsProps>;

export declare const TeliDialogContent: FC<DialogContentProps>;

export declare const TeliDialogTitle: FC<DialogTitleProps>;

export declare const TeliEditIcon: default_2.FC<Partial<TeliIconProps>>;

export declare const TeliHeader: default_2.FC<TeliHeaderProps>;

declare interface TeliHeaderProps extends default_2.HTMLAttributes<HTMLHeadElement> {
    children?: default_2.ReactNode;
    /**
     * Attributes to add to the nav component
     */
    navProps?: NavProps;
}

declare type TeliIconProps = default_2.HTMLAttributes<SVGElement> & {
    /**
     * Can be used to control the size of the icon
     */
    size: SizeProp;
};

export declare const TeliInput: default_2.FC<TeliInputProps>;

declare type TeliInputProps = Omit<InputProps, "classes" | "color" | "components" | "componentsProps" | "disableUnderline" | "inputComponent" | "inputProps" | "slotProps" | "slots" | "sx"> & Partial<{
    cursor: default_2.CSSProperties["cursor"];
    textAlign: default_2.CSSProperties["textAlign"];
}>;

export declare const TeliList: FC<TeliListProps>;

export declare const TeliListItem: FC<TeliListItemProps>;

export declare const TeliListItemButton: FC<TeliListItemButtonProps>;

declare type TeliListItemButtonProps = default_2.HTMLAttributes<HTMLButtonElement> & Partial<{
    alignItems: ListItemButtonProps_2["alignItems"];
    autoFocus: ListItemButtonProps_2["autoFocus"];
    dense: ListItemButtonProps_2["dense"];
    disabled: ListItemButtonProps_2["disabled"];
    disableGutters: ListItemButtonProps_2["disableGutters"];
    divider: ListItemButtonProps_2["divider"];
    selected: ListItemButtonProps_2["selected"];
}>;

declare type TeliListItemProps = default_2.HTMLAttributes<HTMLLIElement> & Partial<{
    alignItems: ListItemProps_2["alignItems"];
    children: ListItemProps_2["children"];
    dense: ListItemProps_2["dense"];
    disableGutters: ListItemProps_2["disableGutters"];
    disablePadding: ListItemProps_2["disablePadding"];
    divider: ListItemProps_2["divider"];
    secondaryAction: ListItemProps_2["secondaryAction"];
}>;

export declare type TeliListProps = default_2.HTMLAttributes<HTMLUListElement> & Partial<{
    dense: ListProps_2["dense"];
    disablePadding: ListProps_2["disablePadding"];
    subheader: ListProps_2["subheader"];
}>;

export declare const TeliMenu: FC<MenuProps>;

export declare const TeliMenuItem: FC<MenuItemProps>;

export declare const TeliSearchIcon: default_2.FC<Partial<TeliIconProps>>;

export declare const TeliSelect: default_2.FC<TeliSelectProps>;

declare type TeliSelectOption = {
    id?: any;
    value?: any;
    label: default_2.ReactNode | string;
};

declare interface TeliSelectProps {
    /**
     * If true, the component is initially open. Use when the component open state
     * is not controlled (i.e. the open prop is not defined). You can only use it
     * when the native prop is false (default).
     * @default false
     */
    defaultOpen?: boolean;
    /**
     * The default value. Use when the component is not controlled.
     */
    defaultValue?: any;
    /**
     * If true, the label, input and helper text should be displayed in a disabled
     * state.
     */
    disabled?: boolean;
    /**
     * If true, the label is displayed in an error state.
     */
    error?: boolean;
    /**
     * If true, the component is displayed in focused state.
     */
    focused?: boolean;
    /**
     * If true, the component will take up the full width of its container.
     */
    fullWidth?: boolean;
    /**
     * If true, the label is hidden. Be sure to add aria-label to the input
     * element.
     */
    hiddenLabel?: boolean;
    /**
     * The id of the input element.
     */
    id?: string;
    /**
     * The label of the input.
     */
    label?: string;
    /**
     * Text which will be displayed below the component. If ' ' is provided, the
     * component reserves one line height for displaying a future message.
     */
    helperText?: string;
    /**
     * If true, value must be an array and the menu will support multiple
     * selections.
     */
    multiple?: boolean;
    /**
     * Callback fired when a menu item is selected.
     * @param event The event source of the callback. You can pull out the new
     * value by accessing event.target.value (any). Warning: This is a generic
     * event, not a change event, unless the change event is caused by browser
     * autofill.
     * @returns void
     */
    onChange?: (event: SelectChangeEvent) => void;
    /**
     * Callback fired when the component requests to be closed. Use it in either
     * controlled (see the open prop), or uncontrolled mode (to detect when the
     * Select collapses).
     * @param event The event source of the callback.
     * @returns void
     */
    onClose?: (event: object) => void;
    /**
     * Callback fired when the component requests to be opened. Use it in either
     * controlled (see the open prop), or uncontrolled mode (to detect when the
     * Select expands).
     * @param event The event source of the callback.
     * @returns void
     */
    onOpen?: (event: object) => void;
    /**
     * If true, the component is shown.
     */
    open?: boolean;
    /**
     * The option elements to populate the select with
     * type TeliSelectOption = {
     id?: any;
     value?: any;
     label: React.ReactNode | string;
     };
     */
    options?: TeliSelectOption[];
    renderValue?: SelectProps_2["renderValue"];
    /**
     * If true, the selected option(s) cannot be changed
     */
    readOnly?: boolean;
    /**
     * If true, the label will indicate that the input is required.
     */
    required?: boolean;
    /**
     * The id of the select wrapper element
     */
    selectId?: string;
    /**
     * The width of the component
     */
    width?: number;
    /**
     * The input value. Providing an empty string will select no options. Set to
     * an empty string '' if you don't want any of the available options to be
     * selected. If the value is an object it must have reference equality with
     * the option in order to be selected. If the value is not an object, the
     * string representation must match with the string representation of the
     * option in order to be selected.
     */
    value?: any;
}

export declare const TeliSortAZIcon: default_2.FC<Partial<TeliIconProps>>;

export declare const TeliSortZAIcon: default_2.FC<Partial<TeliIconProps>>;

export declare const TeliSpinner: FC<CircularProgressProps_2>;

export declare const TeliStandardLayout: default_2.FC<TeliStandardLayoutProps>;

declare interface TeliStandardLayoutHeaderProps {
    /**
     * The list of applications to include in the app switcher
     */
    apps?: AppSwitchProps["apps"];
    /**
     * The telicent application name
     */
    appName: TeliBrandProps["appName"];
    /**
     * Has the application moved into its second phase of testing and is ready for external use by customers or clients?
     * @default false
     */
    beta?: TeliBrandProps["beta"];
    /**
     * TeliUserProfile component
     */
    userProfile?: default_2.ReactNode;
}

declare type TeliStandardLayoutProps = TeliStandardLayoutHeaderProps & MainProps;

/**
 * Switches toggle the state of a single setting on or off. The option that the
 * switch controls, as well as the state it's in, should be made clear from the
 * corresponding inline label. If unsure when to use toggle switch or checkbox,
 * refer to [Checkbox vs Toggle
 * Switch](https://uxplanet.org/checkbox-vs-toggle-switch-7fc6e83f10b8)
 */
export declare const TeliSwitch: FC<TeliSwitchProps>;

declare interface TeliSwitchProps {
    /**
     * If true, the component is checked.
     */
    checked?: boolean;
    /**
     * The default checked state. Use when the component is not controlled.
     */
    defaultChecked?: boolean;
    /**
     * If true, the component is disabled.
     */
    disabled?: boolean;
    /**
     * If given, uses a negative margin to counteract the padding on one side
     * (this is often helpful for aligning the left or right side of the icon with
     * content above or below, without ruining the border size and shape).
     */
    edge?: "end" | "start";
    /**
     * The id of the input element.
     */
    id?: string;
    /**
     * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attributes)
     * applied to the input element.
     */
    inputProps?: HTMLAttributes<HTMLInputElement>;
    /**
     * Pass a ref to the input element.
     */
    inputRef?: default_2.RefObject<HTMLInputElement> | null;
    /**
     * Text to be used in an enclosing label element.
     */
    label?: string;
    /**
     * The position of the label.
     * @default end
     */
    labelPlacement?: "start" | "end";
    /**
     * Callback fired when the state is changed. <code>event</code> The event
     * source of the callback. You can pull out the new value by accessing
     * event.target.value (string). You can pull out the new checked state by
     * accessing event.target.checked (boolean)
     */
    onChange?: (event: default_2.ChangeEvent) => void;
    /**
     * If true, the input element is required.
     */
    required?: boolean;
    /**
     * The size of the component. small is equivalent to the dense switch styling.
     * @default small
     */
    size?: "small" | "medium";
    /**
     * The value of the component. The DOM API casts this to a string. The browser
     * uses "on" as the default value.
     */
    value?: any;
}

export declare const TeliTab: default_2.FC<TeliTabProps>;

export declare const TeliTable: default_2.FC<TeliTableProps>;

export declare const TeliTableBody: default_2.FC<TeliTableBody_2_2>;

export declare type TeliTableBody_2 = Omit<TableBodyProps, "sx" | "classes">;

declare type TeliTableBody_2 = Omit<TableBodyProps, "sx" | "classes">;

declare type TeliTableBody_2_2 = Omit<TableBodyProps, "sx" | "classes">;

export declare const TeliTableCell: default_2.FC<TeliTableCellProps>;

declare interface TeliTableCellProps extends TableCellProps {
    /**
     * Minimum width of the table
     */
    minWidth?: number;
}

export declare const TeliTableContainer: default_2.FC<TeliTableContainerProps>;

declare interface TeliTableContainerProps extends TableContainerProps {
    /**
     * If true, the table element will be bordered
     */
    bordered?: boolean;
    /**
     * Maximum height of the component
     */
    maxHeight?: number;
}

export declare const TeliTableHead: default_2.FC<TeliTableHeadProps>;

declare type TeliTableHeadProps = Omit<TableHeadProps, "sx" | "classes">;

declare interface TeliTableProps extends TableProps {
    /**
     * If true, the table will be compact (smaller)
     */
    compact?: boolean;
    /**
     * Minimum width of the table
     */
    minWidth?: number;
    /**
     * The name of the table element
     */
    name?: string;
}

export declare const TeliTableRow: default_2.FC<TeliTableRowProps>;

declare interface TeliTableRowProps extends TableRowProps {
    /**
     * If true, the last table row will have a bottom border added to the table
     * cell element
     */
    addBorderToLastRow?: boolean;
}

export declare const TeliTabPanel: default_2.FC<TeliTabPanelProps>;

declare interface TeliTabPanelProps {
    tabIndex: number;
    selectedTabIndex: number;
    children?: default_2.ReactNode;
}

declare interface TeliTabProps extends Omit<TabProps, "value"> {
    tabIndex: number;
}

export declare const TeliTabs: default_2.FC<TeliTabsProps>;

declare interface TeliTabsProps extends Omit<TabsProps, "value"> {
    /**
     * The value of the currently selected `Tab`.
     */
    selectedTabIndex: number;
}

/**
 * Text Fields let users enter and edit text. They typically appear in forms and dialogs.
 * More information about this component can be used can be found [here](https://mui.com/material-ui/react-text-field/)
 */
export declare const TeliTextField: FC<TeliTextFieldProps>;

declare interface TeliTextFieldProps {
    ariaLabel?: string;
    /** This prop helps users to fill forms faster, especially on mobile devices.
     * The name can be confusing, as it's more like an autofill. You can learn
     * more about it [following the
     * specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
     * */
    autoComplete?: TextFieldProps["autoComplete"];
    /** If true, the input element is focused during the first mount.
     * @default false
     */
    autoFocus?: TextFieldProps["autoFocus"];
    /** The default value. Use when the component is not controlled. */
    defaultValue?: TextFieldProps["defaultValue"];
    /** If true, the component is disabled.
     *  @default false
     */
    disabled?: TextFieldProps["disabled"];
    /** If true, the label is displayed in an error state.
     *  @default false
     */
    error?: TextFieldProps["error"];
    /** End InputAdornment for this component. */
    endAdornment?: React.ReactNode | string;
    /** If true, the input will take up the full width of its container.
     * @default false
     */
    fullWidth?: TextFieldProps["fullWidth"];
    /** The helper text content. */
    helperText?: TextFieldProps["helperText"];
    /** The id of the input element. Use this prop to make label and helperText
     * accessible for screen readers. */
    id?: TextFieldProps["id"];
    /** Pass a ref to the input element. */
    inputRef?: TextFieldProps["inputRef"];
    /** The label content. */
    label?: TextFieldProps["label"];
    /** Maximum number of rows to display when multiline option is set to true. */
    maxRows?: TextFieldProps["maxRows"];
    /** Minimum number of rows to display when multiline option is set to true. */
    minRows?: TextFieldProps["minRows"];
    /** If true, a textarea element is rendered instead of an input. */
    multiline?: TextFieldProps["multiline"];
    /** Name attribute of the input element. */
    name?: TextFieldProps["name"];
    /** Callback fired when the value is changed.
     * (event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => void
     * @param event The event source of the callback. You can pull out the new
     * value by accessing event.target.value (string).
     * @returns void
     */
    onChange?: TextFieldProps["onChange"];
    /** The short hint displayed in the input before the user enters a value. */
    placeholder?: TextFieldProps["placeholder"];
    /** If true, the label is displayed as required and the input element is required. */
    required?: TextFieldProps["required"];
    /** Number of rows to display when multiline option is set to true. */
    rows?: TextFieldProps["rows"];
    /** Start InputAdornment for this component. */
    startAdornment?: React.ReactNode | string;
    /** If true, pointer events like onClick are enabled */
    pointerEvents?: boolean;
    /** If true, the input value cannot be changed */
    readOnly?: boolean;
    /** Type of the input element. It should be a [valid HTML5 input
     * type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
     * */
    type?: TextFieldProps["type"];
    /** The value of the input element, required for a controlled component. */
    value?: TextFieldProps["value"];
}

export declare const TeliToolbar: default_2.FC<TeliToolbarProps>;

declare interface TeliToolbarProps extends HTMLAttributes<HTMLUListElement> {
    /**
     * @default true
     */
    defaultControls?: boolean;
    /**
     * @default false
     */
    vertical?: boolean;
    position?: "bottom-start" | "bottom-end" | "top-start" | "top-end";
    variant?: "tertiary" | "basic";
    onZoomIn?: () => void;
    onZoomOut?: () => void;
    children?: default_2.ReactNode;
}

export declare function TeliTypeahead<Value, Multiple extends boolean = false, DisableClearable extends boolean = false, FreeSolo extends boolean = false>({ errorMessage, helperText, queryParamKey, url, noOptionsText, onTransform, ...otherProps }: TeliTypeaheadProps<Value, Multiple, DisableClearable, FreeSolo>): JSX_2.Element;

declare interface TeliTypeaheadProps<Value, Multiple extends boolean = false, DisableClearable extends boolean = false, FreeSolo extends boolean = false> extends Omit<TeliAutocompleteProps<Value, Multiple, DisableClearable, FreeSolo>, "options"> {
    errorMessage?: string;
    queryParamKey: string;
    url: string;
    onTransform?: (data: any) => any;
}

/**
 * This component can be used to display type/class iconography defined in the
 * ontology. If the styles cannot be found, the initials will be rendered as a
 * fallback as demonstrated in the stories.
 */
export declare const TeliTypeIcon: default_2.FC<TeliTypeIconProps>;

export declare type TeliTypeIconProps = {
    icon: FlattenedStyleTypeForFindIcon | FlattenedStyleType;
} & Partial<{
    /**
     * Can be used to override the border color defined in the ontology
     */
    borderColor: string;
    /**
     * If true, the component will be rendered in a disabled state
     */
    disabled: boolean;
    /**
     * Used to control the size of the component
     */
    size: TeliTypeIconSizeProp;
}>;

declare type TeliTypeIconSizeProp = "xs" | "sm" | "base" | "lg";

declare interface TeliUserAvatarProps {
    /**
     * Provides an alt attribute for the rendered img element.
     */
    alt: AvatarProps["alt"];
    /**
     * User's first name
     */
    firstName: string;
    /**
     * User's last name
     */
    lastName: string;
    /**
     * The src attribute for the img element.
     */
    src: AvatarProps["src"];
}

export declare const TeliUserProfile: default_2.FC<Partial<TeliUserProfileProps>>;

declare interface TeliUserProfileMenuProps {
    anchorEl: MenuProps["anchorEl"];
    firstName?: string;
    lastName?: string;
    open: boolean;
    onClose: () => void;
    /**
     * Callback fired when the settings menu item is clicked
     * @param event
     * @returns
     */
    onSettingsClick?: (event: default_2.SyntheticEvent) => void;
}

declare interface TeliUserProfileProps extends Partial<TeliUserAvatarProps> {
    onSettingsClick: TeliUserProfileMenuProps["onSettingsClick"];
}

declare const Text_2: default_2.FC<TextProps>;
export { Text_2 as Text }

export declare const TextField: default_2.ForwardRefExoticComponent<(Omit<OutlinedTextFieldProps & {
    errorText?: default_2.ReactNode;
}, "ref"> | Omit<FilledTextFieldProps & {
    errorText?: default_2.ReactNode;
}, "ref"> | Omit<StandardTextFieldProps & {
    errorText?: default_2.ReactNode;
}, "ref">) & default_2.RefAttributes<HTMLInputElement>>;

export declare type TextProps = BaseProps & Partial<{
    /**
     * If true, the element will be a paragraph element.
     */
    paragraph: boolean;
    /**
     * The type of text style to use.
     */
    variant: "subtitle1" | "subtitle2" | "body1" | "body2" | "overline" | "caption";
}>;

export declare const TitleAndContent: FC<TitleAndContentProps>;

declare interface TitleAndContentProps {
    title?: string;
    content?: string;
}

export declare type ToggleFn = (id: string) => void;

export declare const Toolbar: default_2.FC<ToolbarProps>;

export declare const TooltipToggleButton: default_2.FC<TooltipToggleButtonProps>;

declare interface TooltipToggleButtonProps extends Omit<ToggleButtonProps, "sx" | "classes" | "color"> {
    /**
     * Tooltip text
     */
    tooltip?: string;
}

export declare const toStringEncoded: (params: URLSearchParamsInit, codec: Codec) => string;

export declare const TreeView: default_2.FC<TreeViewProps>;

export { TreeViewBaseItem }

export declare type TreeViewProps<Item extends object = TreeViewBaseItem> = {
    items: Item[];
} & Partial<{
    /**
     * Force children to always be expanded
     */
    alwaysExpandedIds: string[];
    /**
     * Expanded item ids. Used when the item's expansion is not controlled.
     */
    defaultExpandedItems: string[];
    /**
     * Selected item ids. (Uncontrolled) When multiSelect is true this takes an
     * array of strings; when false (default) a string.
     */
    defaultSelectedItems: string | string[];
    /**
     * 	Expanded item ids. Used when the item's expansion is controlled.
     */
    expandedItems: string[];
    /**
     * Used to determine the id of a given item.
     * @param item The item to check.
     * @returns  The id of the item.
     * @default (item) => item.id
     */
    getItemId: (item: Item) => string;
    /**
     * Used to determine the string label for a given item.
     * @param item The item to check.
     * @returns The label of the item.
     * @default (item) => item.label
     */
    getItemLabel: (item: Item) => string;
    /**
     * This prop is used to help implement the accessibility logic. If you don't
     * provide this prop, it falls back to a randomly generated id.
     */
    id: string;
    /**
     * Used to determine if a given item should be disabled.
     * @param item  The item to check.
     * @returns true if the item should be disabled.
     */
    isItemDisabled: (item: Item) => boolean;
    /**
     * 	If true ctrl and shift will trigger multiselect.
     * @default false
     */
    multiSelect: boolean;
    /**
     * Callback fired when tree items are expanded/collapsed.
     * @param event The event source of the callback.
     * @param itemIds The ids of the expanded items.
     * @returns void
     */
    onExpandedItemsChange: (event: default_2.SyntheticEvent, itemIds: string[]) => void;
    /**
     * Callback fired when a tree item is expanded or collapsed.
     * @param event The event source of the callback.
     * @param itemId The itemId of the modified item.
     * @param isExpanded true if the item has just been expanded, false if it has
     * just been collapsed.
     * @returns void
     */
    onItemExpansionToggle: (event: default_2.SyntheticEvent, itemId: string, isExpanded: boolean) => void;
    /**
     * Callback fired when tree items are focused.
     * @param event The event source of the callback Warning: This is a generic event not a focus event.
     * @param itemId The id of the focused item.
     * @returns void
     */
    onItemFocus: (event: default_2.SyntheticEvent | null, itemId: string) => void;
    /**
     * Callback fired when a tree item is selected or deselected.
     * @param event The event source of the callback.
     * @param itemId The itemId of the modified item.
     * @param isSelected true if the item has just been selected, false if it has
     * just been deselected.
     * @returns void
     */
    onItemSelectionToggle: (event: default_2.SyntheticEvent, itemId: string, isSelected: boolean) => void;
    /**
     * Callback fired when tree items are selected/deselected.
     * @param event The event source of the callback
     * @param itemIds The ids of the selected items. When multiSelect is true,
     * this is an array of strings; when false (default) a string.
     * @returns void
     */
    onSelectedItemsChange: (event: default_2.SyntheticEvent, itemIds: string[] | string | null) => void;
    /**
     * Selected item ids. (Controlled) When multiSelect is true this takes an
     * array of strings; when false (default) a string.
     */
    selectedItems: string | string[];
    sx: SxProps_2;
}>;

export declare type UITheme = default_3.infer<typeof UIThemeSchema>;

export declare const UIThemeProvider: default_2.FC<UIThemeProviderProps>;

declare type UIThemeProviderProps = default_2.PropsWithChildren & {
    theme: UITheme;
    dark?: boolean;
};

export declare const UIThemeSchema: default_3.ZodEnum<["DataNavy", "DocumentPink", "GraphOrange", "AdminBlue", "Blank"]>;

export declare const uriComponentCodec: Codec;

export { URLSearchParamsInit }

export declare const useAuth: () => AuthContextProps;

export declare const useDebounce: (value: any, delay?: number) => any;

/**
 *
 * @param ref ref from fowardedRef.
 * @param initialOpen
 * @param onVisibilityChange
 * @returns
 */
export declare function useDrawer(args: {
    ref: ForwardedRef<DrawerController>;
    initialOpen: boolean;
    onVisibilityChange?: (open: boolean) => void;
}): {
    open: boolean;
    openDrawer: () => void;
    closeDrawer: () => void;
    toggleDrawer: () => void;
    ref: RefObject<HTMLDivElement>;
    drawerProps: {
        ref: RefObject<HTMLDivElement>;
        onToggle: () => void;
        onClose: () => void;
        open: boolean;
    };
};

export declare const useExtendedTheme: () => ExtendedTheme;

export declare const useFloatingPanels: () => {
    panels: string[];
};

export { useMap }

export declare const useMapCanvasContext: () => MapCanvasState;

export declare const UserIcon: default_2.FC<SvgIconProps_2>;

export declare const UserProfile: default_2.FC<UserProfileProps>;

export declare const UserProfileContent: default_2.FC<PropsWithChildren>;

export declare type UserProfileProps = PropsWithChildren & {
    fullName: string;
};

export declare const UserStatus: default_2.FC<UserStatusProps>;

export declare type UserStatusProps = PropsWithChildren & {
    fullName: string;
};

export declare const XIcon: default_2.FC<SvgIconProps>;

export { }
